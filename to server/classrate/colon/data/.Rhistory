which <- foldid == i
y_train <- y[!which]
x_train <- x[!which, , drop = FALSE]
outlist[[i]] <- gcdnetpower(x = x_train, y = y_train, lambda = lambda,
lambda2 = l2, qv = qv, method="power")
}
predmat <- matrix(NA, length(y), length(lambda))
nlams <- double(nfolds)
for (i in seq(nfolds)) {
which <- foldid == i
fitobj <- outlist[[i]]
preds <- predict(fitobj, x[which, , drop = FALSE], type = "link")
nlami <- length(outlist[[i]]$lambda)
predmat[which, seq(nlami)] <- preds
nlams[i] <- nlami
}
N <- nrow(x)
m = gcdnetpower(x=x, y=y,
lambda2 = l2, qv = qv, method="power")
lambda = m$lambda
# Parameters of the function
nfolds = 5
foldid <- sample(rep(seq(nfolds), length = N))
outlist <- as.list(seq(nfolds))
###Now fit the nfold models and store them
for (i in seq(nfolds)) {
which <- foldid == i
y_train <- y[!which]
x_train <- x[!which, , drop = FALSE]
outlist[[i]] <- gcdnetpower(x = x_train, y = y_train, lambda = lambda,
lambda2 = l2, qv = qv, method="power")
}
predmat <- matrix(NA, length(y), length(lambda))
nlams <- double(nfolds)
for (i in seq(nfolds)) {
which <- foldid == i
fitobj <- outlist[[i]]
preds <- predict(fitobj, x[which, , drop = FALSE], type = "link")
nlami <- length(outlist[[i]]$lambda)
predmat[which, seq(nlami)] <- preds
nlams[i] <- nlami
}
cv.GCDpower()
cv.GCDpower(x=dat$x, y=dat$y,
lambda2=1.5, delta=2/9, method="hhsvm",eps=1e-8)
cv.GCDpower(x=dat$x, y=dat$y,
lambda2=1.5, qv=2, method="power",eps=1e-8)
cv.predict.GCDpower(x=dat$x, y=dat$y,
lambda2=1.5, qv=2, method="power",eps=1e-8)
predict.cv.GCDpower(x=dat$x, y=dat$y,
lambda2=1.5, qv=2, method="power",eps=1e-8)
cv.GCDpower(x=dat$x, y=dat$y,
lambda2=1.5, qv=2, method="power",eps=1e-8)
rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
require(Matrix)
# Main program
source("M_GCDpower.R")
# Prediction, plot
source("M_p.GCDpower.R")
# coefficients
source("M_coef.GCDpower.R")
# KKT
source("U_KKTcheckings.R")
d
dyn.load("M_powerfamilyNET.dll")
load("D_FHT.rda")
dat=FHT
x=dat$x
y=dat$y
m = gcdnetpower(x=x, y=y,
lambda2 = l2, qv = qv, method="power")
lambda = m$lambda
# Parameters of the function
nfolds = 5
foldid <- sample(rep(seq(nfolds), length = N))
outlist <- as.list(seq(nfolds))
###Now fit the nfold models and store them
for (i in seq(nfolds)) {
which <- foldid == i
y_train <- y[!which]
x_train <- x[!which, , drop = FALSE]
outlist[[i]] <- gcdnetpower(x = x_train, y = y_train, lambda = lambda,
lambda2 = l2, qv = qv, method="power")
}
N=nrow(x)
foldid <- sample(rep(seq(nfolds), length = N))
foldid <- sample(rep(seq(nfolds), length = N))
outlist <- as.list(seq(nfolds))
###Now fit the nfold models and store them
for (i in seq(nfolds)) {
which <- foldid == i
y_train <- y[!which]
x_train <- x[!which, , drop = FALSE]
outlist[[i]] <- gcdnetpower(x = x_train, y = y_train, lambda = lambda,
lambda2 = l2, qv = qv, method="power")
}
predmat <- matrix(NA, length(y), length(lambda))
nlams <- double(nfolds)
for (i in seq(nfolds)) {
which <- foldid == i
fitobj <- outlist[[i]]
preds <- predict(fitobj, x[which, , drop = FALSE], type = "link")
nlami <- length(outlist[[i]]$lambda)
predmat[which, seq(nlami)] <- preds
nlams[i] <- nlami
}
# This program aims to find the best lambda_1
rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
require(Matrix)
# Source files with tool functions.
source("O_utilities.R")
# Main program
source("M_GCDpower.R")
# Prediction, plot
source("M_p.GCDpower.R")
# KKT checking, CV
source("M_tools.GCDpower.R")
# coefficients
source("M_coef.GCDpower.R")
# KKT
source("U_KKTcheckings.R")
dyn.load("M_powerfamilyNET.dll")
qv = 1
l2 = 0
# Data files
load("D_FHT.rda")
dat=FHT
x=dat$x
y=dat$y
N=nrow(x)
m = gcdnetpower(x=x, y=y,
lambda2 = l2, qv = qv, method="power")
lambda = m$lambda
# Parameters of the function
nfolds = 5
foldid <- sample(rep(seq(nfolds), length = N))
outlist <- as.list(seq(nfolds))
###Now fit the nfold models and store them
for (i in seq(nfolds)) {
which <- foldid == i
y_train <- y[!which]
x_train <- x[!which, , drop = FALSE]
outlist[[i]] <- gcdnetpower(x = x_train, y = y_train, lambda = lambda,
lambda2 = l2, qv = qv, method="power")
}
predmat <- matrix(NA, length(y), length(lambda))
nlams <- double(nfolds)
for (i in seq(nfolds)) {
which <- foldid == i
fitobj <- outlist[[i]]
preds <- predict(fitobj, x[which, , drop = FALSE], type = "link")
nlami <- length(outlist[[i]]$lambda)
predmat[which, seq(nlami)] <- preds
nlams[i] <- nlami
}
predmat
fitobj
class(fitobj)
nlams
predmat
cvraw <- switch(pred.loss, misclass = (y != ifelse(predmat > 0, 1, -1)))
cvraw <- switch("misclass", misclass = (y != ifelse(predmat > 0, 1, -1)))
cvraw
(y != ifelse(predmat > 0, 1, -1))
cvraw <- (y != ifelse(predmat > 0, 1, -1))
cvraw
nfolds
foldid
outmat <- matrix(NA, nfolds, ncol(mat))
mat= cvraw
nfolds <- max(foldid)
outmat <- matrix(NA, nfolds, ncol(mat))
good <- matrix(0, nfolds, ncol(mat))
mat[is.infinite(mat)] <- NA
mat[is.infinite(mat)]
or (i in seq(nfolds)) {
mati <- mat[foldid == i, ]
outmat[i, ] <- apply(mati, 2, mean, na.rm = TRUE)
good[i, seq(nlams[i])] <- 1
}
N <- apply(good, 2, sum)
list(cvraw = outmat, N = N)
for (i in seq(nfolds)) {
mati <- mat[foldid == i, ]
outmat[i, ] <- apply(mati, 2, mean, na.rm = TRUE)
good[i, seq(nlams[i])] <- 1
}
N <- apply(good, 2, sum)
list(cvraw = outmat, N = N)
good
?apply
N
mati <- mat[foldid == i, ]
mati
cvraw
good <- matrix(0, nfolds, ncol(mat))
good
seq(nfolds)
i=1
mati <- mat[foldid == i, ]
mati
apply(mati, 2, mean, na.rm = TRUE)
y
ifelse(predmat > 0, 1, -1)
y
cvraw <- (y != ifelse(predmat > 0, 1, -1))
cvraw
cvraw <- (y != ifelse(predmat > 0, 1, -1))
mat= cvraw
nfolds <- max(foldid)
outmat <- matrix(NA, nfolds, ncol(mat))
good <- matrix(0, nfolds, ncol(mat))
for (i in seq(nfolds)) {
mati <- mat[foldid == i, ]
outmat[i, ] <- apply(mati, 2, mean, na.rm = TRUE)
good[i, seq(nlams[i])] <- 1
}
N <- apply(good, 2, sum)
list(cvraw = outmat, N = N)
cvob = list(cvraw = outmat, N = N)
cvraw <- cvob$cvraw
N <- cvob$N
N
cvraw
cvm <- apply(cvraw, 2, mean, na.rm = TRUE)
cvm
mean(c(.7,.6,.6,.5,.5))
?scale
scale(cvraw, cvm, FALSE)^2
N
cvstuff = list(cvm = cvm, cvsd = cvsd, name = typenames[pred.loss])
cvsd <- sqrt(apply(scale(cvraw, cvm, FALSE)^2, 2, mean, na.rm = TRUE)/(N - 1))
cvstuff = list(cvm = cvm, cvsd = cvsd, name = typenames[pred.loss])
cvstuff = list(cvm = cvm, cvsd = cvsd, name = "Misclassification Error")
cvstuff
cvm <- cvstuff$cvm
cvsd <- cvstuff$cvsd
cvname <- cvstuff$name
out <- list(lambda = lambda, cvm = cvm, cvsd = cvsd, cvupper = cvm +
cvsd, cvlo = cvm - cvsd, nzero = nz, name = cvname, GCDpower.fit = GCDpower.object)
lamin <- getmin(lambda, cvm, cvsd)
lambda
cvm
cvsd
cvmin <- min(cvm)
cvmin
cvm
cvm <= cvmin
idmin <- cvm <= cvmin
idmin
lambda.min <- max(lambda[idmin])
lambda.min
lambda
idmin <- match(lambda.min, lambda)
idmin
semin <- (cvm + cvsd)[idmin]
idmin <- cvm <= semin
semin
idmin
list(lambda.min = lambda.min, lambda.1se = lambda.1se)
lambda.1se <- max(lambda[idmin])
lambda.1se
list(lambda.min = lambda.min, lambda.1se = lambda.1se)
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2 = l2,
pred.loss="misclass", nfolds=5))[3]
source("M_p.GCDpower.R")
# KKT checking, CV
source("M_tools.GCDpower.R")
# coefficients
source("M_coef.GCDpower.R")
# KKT
source("U_KKTcheckings.R")
dyn.load("M_powerfamilyNET.dll")
source("M_tools.GCDpower.R")
qv = 1
l2 = 0
# Data files
load("D_FHT.rda")
dat=FHT
x = dat$x
y = dat$y
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2 = l2,
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$hubernet2.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2 = l2,
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$hubernet2.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
cv.GCDpower
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2=l2, method="power",
pred.loss="misclass", nfolds=5))[3]
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2=l2, #method="power",
pred.loss="misclass", nfolds=5))[3]
source("M_GCDpower.R")
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2=l2, #method="power",
pred.loss="misclass", nfolds=5))[3]
cv
summary(cv)
pre = predict(cv$GCDpower.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
pre
error = (test_y != pre)
error
nrep = 10
seed = sample((1:nrep)+2001,nrep)
ans = matrix(0,7,nrep)
time = matrix(0,7,nrep)
for (j in 1:nrep){
i=1
set.seed(seed[j])
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
for(lambda2 in c(1e-4,1e-3,1e-2,1e-1,1,5,10)){
tim <- system.time(cv<-cv.hubernet2(train_x, train_y, eps=1e-8,
lambda2 = lambda2, maxit = 3e7,
pred.loss="misclass", lambda.factor=0.01,nfolds=5))[3]
pre = predict(cv$hubernet2.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
ans[i,j] = res = sum(error)/length(error)
time[i,j] = tim
i = i + 1
}}
nrep = 10
seed = sample((1:nrep)+2001,nrep)
ans = matrix(0,7,nrep)
time = matrix(0,7,nrep)
for (j in 1:nrep){
i=1
set.seed(seed[j])
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
for(lambda2 in c(1e-4,1e-3,1e-2,1e-1,1,5,10)){
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8,
lambda2=l2, method="power",
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$GCDpower.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
ans[i,j] = res = sum(error)/length(error)
time[i,j] = tim
i = i + 1
}}
time
ans
apply(ans,1,mean)*100
apply(time,1,mean)
time
qv = 1
FHT = FHTgen(n=100, p=5000, rho=0.8)
dat=FHT
x = dat$x
y = dat$y
nrep = 10
seed = sample((1:nrep) + 2001, nrep)
ans = matrix(0, 7, nrep)
time = matrix(0, 7, nrep)
for (j in 1:nrep){
i=1
set.seed(seed[j])
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
for(lambda2 in c(1e-4,1e-3,1e-2,1e-1,1,5,10)){
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8, qv=qv,
lambda2=lambda2, method="power",
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$GCDpower.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
ans[i,j] = res = sum(error)/length(error)
time[i,j] = tim
i = i + 1
}}
source("M__FHTgen.R")
setwd("D:\\GitHub\\powerfamily")
source("M__FHTgen.R")
source("M_FHTgen.R")
qv = 1
FHT = FHTgen(n=100, p=5000, rho=0.8)
dat=FHT
x = dat$x
y = dat$y
nrep = 10
seed = sample((1:nrep) + 2001, nrep)
ans = matrix(0, 7, nrep)
time = matrix(0, 7, nrep)
for (j in 1:nrep){
i=1
set.seed(seed[j])
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
for(lambda2 in c(1e-4,1e-3,1e-2,1e-1,1,5,10)){
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8, qv=qv,
lambda2=lambda2, method="power",
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$GCDpower.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
ans[i,j] = res = sum(error)/length(error)
time[i,j] = tim
i = i + 1
}}
apply(ans,1,mean)*100
apply(time,1,mean)
qv = 2
FHT = FHTgen(n=100, p=5000, rho=0.8)
dat=FHT
x = dat$x
y = dat$y
nrep = 10
seed = sample((1:nrep) + 2001, nrep)
ans = matrix(0, 7, nrep)
time = matrix(0, 7, nrep)
for (j in 1:nrep){
i=1
set.seed(seed[j])
index = sample(1:nrow(x),as.integer(nrow(x)/3),replace=F)
test_x = x[index,]
test_y = y[index]
train_x = x[-index,]
train_y = y[-index]
for(lambda2 in c(1e-4,1e-3,1e-2,1e-1,1,5,10)){
tim = system.time(cv<-cv.GCDpower(train_x, train_y, eps=1e-8, qv=qv,
lambda2=lambda2, method="power",
pred.loss="misclass", nfolds=5))[3]
pre = predict(cv$GCDpower.fit, newx = test_x, s = cv$lambda.1se, type = "class" )
error = (test_y != pre)
ans[i,j] = res = sum(error)/length(error)
time[i,j] = tim
i = i + 1
}}
j
ans
time
apply(time,1,mean)
rm(list = ls(all = TRUE))
setwd("D:\GitHub\powerfamily\data")
setwd("D:\\GitHub\\powerfamily\\data")
load("leukemia.rda")
load("leuk.rda")
head(leuk)
head(x)
class(x)
dim(x)
y
length(y)
# leukemia (n = 72, p = 7128)
load("colon.rda")
x=colon.x
y=colon.y
class(x)
dim(x)
dim(y)
length(y)
sum(dis>=0.5)/length(dis)
load("prostate.rda")
x=prostate.x
y=prostate.y
dim(x)
class(x)
alpha = 0.5
mat_c = cor(x)
dis = mat_c[lower.tri(mat_c)]
setwd("D:\\GitHub\\powerfamily\\data")
load("breast.rda")
load("breast.rda")
x=breast.x
y=breast.y
rm(list = ls(all = TRUE))
setwd("D:\\GitHub\\powerfamily\\data")
load("breast.rda")
breast.x = x
breast.y = y
load("arcene.rda")
rm(list = ls(all = TRUE))
load("arcene.rda")
tx
tx-vx
load("arcene.rda")
arcene.x = tx
arcene.y = ty
arcene
arcene.rda
"arcene.rda"
load("arcene.rda")
y=colon.y
load("colon.rda")
x=colon.x
y=colon.y
args[[i]]
args
