} else{
AA = dl[j,l] + lambda[l] * sign(beta[j,l]) + lambda2 * beta[j,l]
if (abs(sum(AA)) >= thr)
{
cat("violate at b != 0", abs(sum(AA)), "\n")
ctr <- ctr + 1
}
}
}
}
cat("# of violations", ctr/length(lambda), "\n")
return(ctr/length(lambda))
}
#library(gcdnet)
load("D_FHT.rda")
y = FHT$y
x = FHT$x
#x = matrix(c(1,0,-1,-1,1,0),3,2)
#y = c(-1,-1,1)
# Source files with tool functions.
source("O_utilities.R")
# Main program
source("M_GCDpower.R")
# Two FORTRAN subroutines.
dyn.load("M_powerfamilyNET.dll")
dyn.load("O_hsvmlassoNET.dll")
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, qv=2, method="power",eps=1e-10, standardize=F)
plot(m, color=T)
b0=m$b0
beta=m$beta
lambda=m$lambda
# KKT1 = function(b0, beta, y, x, lambda, lambda2, thr, delta, loss = c("hsvm"))
margin(m$b0, m$beta, FHT$y, FHT$x, delta=2, loss = c("power") )
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, qv=2, loss = c("power"))
hsvm <- function(v, varlist) {
delta = varlist$delta
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- (1 - r - delta/2) else dl <- (r - 1)^2/delta/2
dl
}
dhsvm <- function(v, varlist) {
delta = varlist$delta
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- -1 else dl <- (r - 1) / delta
dl
}
power <- function(v, varlist) {
qv = varlist$qv
decib = qv / (qv + 1)
r <- v[1]
dl = ifelse(r > decib, r ^ (-qv) * (qv ^ qv) / ((qv + 1) ^ (qv + 1)), 1 - r)
dl
}
dpower <- function(v, varlist) {
qv = varlist$qv
decib = qv / (qv + 1)
r <- v[1]
dl = ifelse(r > decib, (-1) * r ^ (-qv - 1) * decib ^ (qv + 1), -1)
}
margin <- function(b0, beta, y, x, loss = c("hsvm", "power"), delta=2, qv=2) {
loss <- match.arg(loss)
nobs <- nrow(x)
b0MAT <- matrix(rep(b0, nobs), nrow = nobs, byrow = TRUE)
link <- x %*% beta + b0MAT
if (loss %in% c("hsvm", "power")) {
r <- y * link
} else r <- y - link
fun <- paste("d", loss, sep = "")
varlist = list(delta=delta, qv=qv)
dMat <- apply(r, c(1, 2), eval(fun), varlist) #dMat1
if (loss %in% c("hsvm", "power")) {
yxdMat <- t(x) %*% (dMat * y)/nobs
} else yxdMat <- t(x) %*% dMat/nobs
yxdMat
}
# l is the number of lambda
# p is nvars, n is nobs
# dim(dMat) = n by l
# dim(yxdMat) = p by l
KKT1 = function(b0, beta, y, x, lambda, lambda2, thr,
loss = c("hsvm", "power"), delta=2, qv=2) {
loss = match.arg(loss)
dl = margin(b0, beta, y, x, loss=loss, delta=delta, qv=qv)
ctr = 0
for (l in 1:length(lambda)) {
p = nrow(beta)
for(j in 1:p)
{
if(beta[j,l]==0)
{
BB = abs(dl[j,l]) - lambda[l]
if (BB > thr)
{
cat("violate at b = 0", BB, "\n")
ctr <- ctr + 1
}
} else{
AA = dl[j,l] + lambda[l] * sign(beta[j,l]) + lambda2 * beta[j,l]
if (abs(sum(AA)) >= thr)
{
cat("violate at b != 0", abs(sum(AA)), "\n")
ctr <- ctr + 1
}
}
}
}
cat("# of violations", ctr/length(lambda), "\n")
return(ctr/length(lambda))
}
#library(gcdnet)
load("D_FHT.rda")
y = FHT$y
x = FHT$x
#x = matrix(c(1,0,-1,-1,1,0),3,2)
#y = c(-1,-1,1)
# Source files with tool functions.
source("O_utilities.R")
# Main program
source("M_GCDpower.R")
# Two FORTRAN subroutines.
dyn.load("M_powerfamilyNET.dll")
dyn.load("O_hsvmlassoNET.dll")
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, qv=2, method="power",eps=1e-10, standardize=F)
plot(m, color=T)
b0=m$b0
beta=m$beta
lambda=m$lambda
# KKT1 = function(b0, beta, y, x, lambda, lambda2, thr, delta, loss = c("hsvm"))
# margin(m$b0, m$beta, FHT$y, FHT$x, delta=2, loss = c("power") )
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, qv=2, method="power",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, qv=2, method="power",eps=1e-5, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-7, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-7, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-04, qv=2, loss = c("power"))
KKT1 = function(b0, beta, y, x, lambda, lambda2, thr,
loss = c("hsvm", "power"), delta=2, qv=2) {
loss = match.arg(loss)
dl = margin(b0, beta, y, x, loss=loss, delta=delta, qv=qv)
ctr = 0
ccounts = 0
for (l in 1:length(lambda)) {
p = nrow(beta)
for(j in 1:p)
{
if(beta[j,l]==0)
{
BB = abs(dl[j,l]) - lambda[l]
ccounts = ccounts + 1
if (BB > thr)
{
cat("violate at b = 0", BB, "\n")
ctr <- ctr + 1
}
} else{
AA = dl[j,l] + lambda[l] * sign(beta[j,l]) + lambda2 * beta[j,l]
ccounts = ccounts + 1
if (abs(sum(AA)) >= thr)
{
cat("violate at b != 0", abs(sum(AA)), "\n")
ctr <- ctr + 1
}
}
}
}
cat("# of violations", ctr/length(lambda), "\n")
cat("% of violations", ctr/ccounts*100, "%", "\n")
return(ctr/length(lambda))
}
#library(gcdnet)
load("D_FHT.rda")
y = FHT$y
x = FHT$x
#x = matrix(c(1,0,-1,-1,1,0),3,2)
#y = c(-1,-1,1)
# Source files with tool functions.
source("O_utilities.R")
# Main program
source("M_GCDpower.R")
# Two FORTRAN subroutines.
dyn.load("M_powerfamilyNET.dll")
dyn.load("O_hsvmlassoNET.dll")
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, qv=2, method="power",eps=1e-10, standardize=F)
plot(m, color=T)
b0=m$b0
beta=m$beta
lambda=m$lambda
# KKT1 = function(b0, beta, y, x, lambda, lambda2, thr, delta, loss = c("hsvm"))
# margin(m$b0, m$beta, FHT$y, FHT$x, delta=2, loss = c("power") )
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-04, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="hsvm",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-04, qv=2, loss = c("hsvm"))
#################################################################################
############ checking KKT conditions for HHSVM ################
#################################################################################
hsvm <- function(v, delta) {
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- (1 - r - delta/2) else dl <- (r - 1)^2/delta/2
dl
}
dhsvm <- function(v, delta) {
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- -1 else dl <- (r - 1) / delta
dl
}
margin <- function(b0, beta, y, x, delta, loss = c("hsvm")) {
loss <- match.arg(loss)
nobs <- nrow(x)
b0MAT <- matrix(rep(b0, nobs), nrow = nobs, byrow = TRUE)
link <- x %*% beta + b0MAT
if (loss %in% c("hsvm")) {
r <- y * link
} else r <- y - link
fun <- paste("d", loss, sep = "")
dMat <- apply(r, c(1, 2), eval(fun), delta = delta) #dMat1
if (loss %in% c("hsvm")) {
yxdMat <- t(x) %*% (dMat * y)/nobs
} else yxdMat <- t(x) %*% dMat/nobs
yxdMat
}
# l is the number of lambda
# p is nvars, n is nobs
# dim(dMat) = n by l
# dim(yxdMat) = p by l
KKT1 = function(b0, beta, y, x, lambda, thr, delta, loss = c("hsvm")) {
loss = match.arg(loss)
dl = margin(b0, beta, y, x, delta, loss)
ctr = 0
for (l in 1:length(lambda)) {
p = nrow(beta)
for(j in 1:p)
{
if(beta[j,l]==0)
{
BB = abs(dl[j,l]) - lambda[l]
if (BB > thr)
{
cat("violate at b = 0", BB, "\n")
ctr <- ctr + 1
}
} else{
AA = dl[j,l] + lambda[l] * sign(beta[j,l])
if (abs(sum(AA)) >= thr)
{
cat("violate at b != 0", abs(sum(AA)), "\n")
ctr <- ctr + 1
}
}
}
}
cat("# of violations", ctr/length(lambda), "\n")
return(ctr/length(lambda))
}
margin(m$b0, m$beta, FHT$y, FHT$x, delta=2, loss = c("hsvm") )
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-10, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, thr=1e-03, delta=2, loss = c("hsvm"))
lambda2=0, delta=2,method="hhsvm",eps=1e-7, standardize=F)
#source("GCDpower.R")
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-7, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, thr=1e-03, delta=2, loss = c("hsvm"))
lambda2=0, delta=2,method="hhsvm",eps=1e-6.5, standardize=F)
#source("GCDpower.R")
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-6.5, standardize=F)
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-(6.5), standardize=F)
m <- gcdnet(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2,method="hhsvm",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, thr=1e-03, delta=2, loss = c("hsvm"))
margin <- function(b0, beta, y, x, loss = c("hsvm", "power"), delta=2, qv=2) {
loss <- match.arg(loss)
nobs <- nrow(x)
b0MAT <- matrix(rep(b0, nobs), nrow = nobs, byrow = TRUE)
link <- x %*% beta + b0MAT
if (loss %in% c("hsvm", "power")) {
r <- y * link
} else r <- y - link
fun <- paste("d", loss, sep = "")
varlist = list(delta=delta, qv=qv)
dMat <- apply(r, c(1, 2), eval(fun), varlist) #dMat1
if (loss %in% c("hsvm", "power")) {
yxdMat <- t(x) %*% (dMat * y)/nobs
} else yxdMat <- t(x) %*% dMat/nobs
yxdMat
}
# l is the number of lambda
# p is nvars, n is nobs
# dim(dMat) = n by l
# dim(yxdMat) = p by l
KKT1 = function(b0, beta, y, x, lambda, lambda2, thr,
loss = c("hsvm", "power"), delta=2, qv=2) {
loss = match.arg(loss)
dl = margin(b0, beta, y, x, loss=loss, delta=delta, qv=qv)
ctr = 0
ccounts = 0
for (l in 1:length(lambda)) {
p = nrow(beta)
for(j in 1:p)
{
if(beta[j,l]==0)
{
BB = abs(dl[j,l]) - lambda[l]
ccounts = ccounts + 1
if (BB > thr)
{
cat("violate at b = 0", BB, "\n")
ctr <- ctr + 1
}
} else{
AA = dl[j,l] + lambda[l] * sign(beta[j,l]) + lambda2 * beta[j,l]
ccounts = ccounts + 1
if (abs(sum(AA)) >= thr)
{
cat("violate at b != 0", abs(sum(AA)), "\n")
ctr <- ctr + 1
}
}
}
}
cat("# of violations", ctr/length(lambda), "\n")
cat("% of violations", ctr/ccounts*100, "%", "\n")
return(ctr/length(lambda))
}
#################################################################################
############ checking KKT conditions for power family ################
#################################################################################
hsvm <- function(v, varlist) {
delta = varlist$delta
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- (1 - r - delta/2) else dl <- (r - 1)^2/delta/2
dl
}
dhsvm <- function(v, varlist) {
delta = varlist$delta
r <- v[1]
if (r > 1)
dl <- 0 else if (r <= (1 - delta))
dl <- -1 else dl <- (r - 1) / delta
dl
}
power <- function(v, varlist) {
qv = varlist$qv
decib = qv / (qv + 1)
r <- v[1]
dl = ifelse(r > decib, r ^ (-qv) * (qv ^ qv) / ((qv + 1) ^ (qv + 1)), 1 - r)
dl
}
dpower <- function(v, varlist) {
qv = varlist$qv
decib = qv / (qv + 1)
r <- v[1]
dl = ifelse(r > decib, (-1) * r ^ (-qv - 1) * decib ^ (qv + 1), -1)
}
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2, method="hsvm",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=0, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2, method="hhsvm",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=0, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=0, delta=2, method="hhsvm",eps=1e-7, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=0, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1, delta=2, method="hhsvm",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1, thr=1e-03, delta=2, loss = c("hsvm"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
source("O_utilities.R")
rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
source("O_utilities.R")
source("M_GCDpower.R")
dyn.load("M_powerfamilyNET.dll")
source("U_KKTchecking.R")
source("U_KKTcheckings.R")
dyn.load("M_powerfamilyNET.dll")
load("D_FHT.rda")
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-6, standardize=F)
KKT1(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-7, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-5, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
n=50 # the number of observations
p=100 # the number of predictors
rho=0.5
x=genx2(n,p,rho)
n=10
p=5
rho=0.5
beta=sqrt(rho/(1-rho))
beta
rho=0.4
beta=sqrt(rho/(1-rho))
rho=0.4
beta
x0=matrix(rnorm(n*p),ncol=p)
x0
z=rnorm(n)
z
matrix(z,nrow=n,ncol=p,byrow=F)
beta
beta*matrix(z,nrow=n,ncol=p,byrow=F)
x0
source("M_FHTgen.R")
source("M_FHTgen.R")
FHT = FHTgen(n=100, p=50, rho=0.5)
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-5, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
FHT
FHTgen(n=100, p=50, rho=0.5)
source("M_FHTgen.R")
FHT = FHTgen(n=100, p=50, rho=0.5)
FHT
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-5, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
#lambda=c(0.1,0.01),
lambda2=1.5, qv=2, method="power",eps=1e-7, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03, qv=2, loss = c("power"))
m <- gcdnetpower(x=FHT$x,y=FHT$y,
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT(m$b0, m$beta, FHT$y, FHT$x, m$lambda, lambda2=1.5, thr=1e-03,
qv=2, loss = c("power"))
FHT = FHTgen(n=1000, p=500, rho=0.5)
dat = FHT
m = gcdnetpower(x=dat$x, y=dat$y,
lambda2=1.5, qv=2, method="power",eps=1e-8, standardize=F)
KKT(m$b0, m$beta, dat$y, dat$x, m$lambda, lambda2=1.5, thr=1e-03,
qv=2, loss = c("power"))
