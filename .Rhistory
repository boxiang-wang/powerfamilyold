rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
source("GCDpower.R")
source("utilities.R")
source("plot.gcdnet.R")
require(Matrix)
dyn.load("powerfamilyNET.dll")
dyn.load("hsvmlassoNET.dll")
x_log <- matrix(rnorm(100*10),100,10)
y_log <- sample(c(-1,1),100,replace=TRUE)
# LASSO
m <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="hhsvm")
plot(m)
m <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="power")
plot(m)
m
m
# LASSO
m <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="hhsvm")
plot(m)
m
# LASSO
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="hhsvm")
plot(m1)
m2 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="power")
plot(m2)
m2
m1
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=3,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=1,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=0,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=0.01,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=1000,method="power")
plot(m3)
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.01,method="hhsvm")
plot(m1)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=100,method="power")
plot(m3)
NextMethod
?NextMethod
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.01,method="hhsvm")
plot(m1)
m2 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,method="power")
plot(m2)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=100,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=50,method="power")
plot(m3)
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.01,method="hhsvm")
plot(m1)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=30,method="power")
plot(m3)
# LASSO
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.001,method="hhsvm")
plot(m1)
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0,qv=1,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=1,qv=1,method="power")
plot(m3)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0.5,qv=1,method="power")
plot(m3)
load("FHT.rda")
FHT.rda
FHT
predict.GCDpower <- function(object, newx, s = NULL,
type = c("class", "link"), ...) NextMethod("predict")
predict.hsvmpath <- function(object, newx, s = NULL,
type = c("class", "link"), ...) {
type <- match.arg(type)
b0 <- t(as.matrix(object$b0))
rownames(b0) <- "(Intercept)"
nbeta <- rbind2(b0, object$beta)
if (!is.null(s)) {
vnames <- dimnames(nbeta)[[1]]
dimnames(nbeta) <- list(NULL, NULL)
lambda <- object$lambda
lamlist <- lambda.interp(lambda, s)
nbeta <- nbeta[, lamlist$left, drop = FALSE] * lamlist$frac +
nbeta[, lamlist$right, drop = FALSE] * (1 - lamlist$frac)
dimnames(nbeta) <- list(vnames, paste(seq(along = s)))
}
nfit <- as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
switch(type, link = nfit, class = ifelse(nfit > 0, 1, -1))
}
fit
m
predict(m)
# LASSO
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.001,method="hhsvm")
plot(m1)
m3 <- gcdnetpower(x=x_log,y=y_log,lambda2=0.5,qv=1,method="power")
plot(m3)
print(predict(m3,type="class",newx=FHT$x[2:5,]))
?NextMethod
m1
print(predict(m1,type="class",newx=FHT$x[2:5,]))
source("predict.GCDpower.R")
print(predict(m3,type="class",newx=FHT$x[2:5,]))
print(predict.GCDpower(m3,type="class",newx=FHT$x[2:5,]))
print(predict.GCDpower(m1,type="class",newx=FHT$x[2:5,]))
print(predict.hsvmpath(m1,type="class",newx=FHT$x[2:5,]))
source("predict.hsvmpath.R")
source("predict.hsvmpath.R")
print(predict.GCDpower(m3,type="class",newx=FHT$x[2:5,]))
print(predict.hsvmpath(m1,type="class",newx=FHT$x[2:5,]))
s = NULL,
s = NULL
!is.null(s)
object=m3
b0 <- t(as.matrix(object$b0))
rownames(b0) <- "(Intercept)"
nbeta <- rbind2(b0, object$beta)
nfit <- as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
as.matrix
(cbind2(1, newx))
newx=FHT$x[2:5,])
newx=FHT$x[2:5,]
nfit <- as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
cbind2(1, newx)
as.matrix(cbind2(1, newx))
as.matrix(cbind2(1, newx)) %*% nbeta
nbeta <- rbind2(b0, object$beta)
nbeta
nbeta
as.matrix(cbind2(1, newx))
aaaaa=as.matrix(cbind2(1, newx))
bbbbb=nbeta
dim(aaaaa)
dim(bbbbb)
b0 <- t(as.matrix(object$b0))
b0
nbeta <- rbind2(b0, object$beta)
nbeta
bbbbb=nbeta
dim(bbbbb)
cbind2(1, newx)
dim(cbind2(1, newx))
b0 <- t(as.matrix(object$b0))
rownames(b0) <- "(Intercept)"
nbeta <- rbind2(b0, object$beta)
dim(nbeta)
object
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.001,method="hhsvm")
m1$b0
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.001,method="hhsvm")
m1
m1$b0
rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
x_log <- matrix(rnorm(100*10),100,10)
y_log <- sample(c(-1,1),100,replace=TRUE)
x = x_log
y = y_log
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlambda = 100
lambda.factor = ifelse(nobs < nvars, 0.01,1e-04)
lambda = c(0.5,0.1)
lambda2 = 0.3
pf = rep(1, nvars)
pf2 = rep(1, nvars)
#exclude,
dfmax = nvars + 1
pmax = min(dfmax * 1.2, nvars)
standardize = TRUE
eps = 1e-08
maxit = 1e+06
delta = 2
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
#parameter setup
if (length(pf) != nvars)
stop("The size of L1 penalty factor must be same as the number of input variables")
if (length(pf2) != nvars)
stop("The size of L2 penalty factor must be same as the number of input variables")
if (lambda2 < 0)
stop("lambda2 must be non-negative")
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
isd = 0
isd = as.integer(isd)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
#################################################################################
#lambda setup
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
#################################################################################
#data setup
y <- as.factor(y)
y <- c(-1, 1)[as.numeric(y)]
if (!all(y %in% c(-1, 1)))
stop("y should be a factor with two levels")
if (delta < 0)
stop("delta must be non-negative")
delta <- as.double(delta)
source("plot.gcdnet.R")
source("utilities.R")
require(Matrix)
fit <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
fit
fit$b0
outlist <- getoutput(fit, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit$npass, jerr = fit$jerr))
class(outlist) <- c("hsvmlassoNET")
outlist
fit=outlist
if (is.null(lambda))
fit$lambda <- lamfix(fit$lambda)
fit$call <- this.call
#################################################################################
class(fit) <- c("gcdnet", class(fit))
fit
source("GCDpower.R")
dyn.load("powerfamilyNET.dll")
dyn.load("hsvmlassoNET.dll")
m1 <- gcdnetpower(x=x_log,y=y_log,lambda2=0, delta=0.1,method="hhsvm")
m1
m1 <- gcdnetpower(x=x_log,y=y_log,lambda=c(0.5,0.1),lambda2=0, delta=0.1,method="hhsvm")
m1
rm(list=ls(all=TRUE))
setwd("D:\\GitHub\\powerfamily")
require(Matrix)
source("GCDpower.R")
source("utilities.R")
source("plot.gcdnet.R")
source("predict.GCDpower.R")
source("predict.hsvmpath.R")
dyn.load("powerfamilyNET.dll")
dyn.load("hsvmlassoNET.dll")
load("FHT.rda")
m1 <- gcdnetpower(x=x_log,y=y_log,lambda=c(0.5,0.1),lambda2=0, delta=0.1,method="hhsvm")
m1 <- gcdnetpower(x=x,y=y,lambda=c(0.5,0.1),lambda2=0, delta=0.1,method="hhsvm")
m1 <- gcdnetpower(x=FHT$x,y=FHT$y,lambda=c(0.5,0.1),lambda2=0, delta=0.1,method="hhsvm")
plot(m1)
