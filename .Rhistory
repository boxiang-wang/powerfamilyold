setwd("D:\\GitHub\\powerfamily")
dyn.load("hsvmlassoNET.dll")
x <- matrix(rnorm(100*10),100,10)
y <- sample(c(-1,1),100,replace=TRUE)
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlam = nlambda = 100
method = c("hhsvm","logit", "sqsvm", "ls")
lambda.factor = ifelse(nobs < nvars, 0.01, 1e-04)
lambda = c(0.05,0.1); lambda2 = 0.5
pf = rep(1, nvars); pf2 = rep(1, nvars)
# exclude,
dfmax = nvars + 1; pmax = min(dfmax * 1.2, nvars); standardize = TRUE
eps = 1e-08; maxit = 1e+06; q = 2 ; delta = 2
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
#dyn.load("auxiliary.dll")
dyn.load("hsvmlassoNET.dll")
dyn.load("powerfamilyNET.dll")
is.loaded("powerfamilyNET")
dyn.load("powerfamilyNET.dll")
dyn.load("hsvmlassoNET.dll")
is.loaded("hsvmlassoNET.dll")
is.loaded("hsvmlassoNET")
setwd("D:\\GitHub\\powerfamily")
dyn.load("hsvmlassoNET.dll")
x <- matrix(rnorm(100*10),100,10)
y <- sample(c(-1,1),100,replace=TRUE)
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlam = nlambda = 100
method = c("hhsvm","logit", "sqsvm", "ls")
lambda.factor = ifelse(nobs < nvars, 0.01, 1e-04)
lambda = c(0.05,0.1); lambda2 = 0.5
pf = rep(1, nvars); pf2 = rep(1, nvars)
# exclude,
dfmax = nvars + 1; pmax = min(dfmax * 1.2, nvars); standardize = TRUE
eps = 1e-08; maxit = 1e+06; q = 2 ; delta = 2
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
#dyn.load("auxiliary.dll")
dyn.load("hsvmlassoNET.dll")
dyn.load("powerfamilyNET.dll")
is.loaded("powerfamilyNET")
is.loaded("hsvmlassoNET")
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
fit1
plot(fit1)
source("plot.gcdnet.R")
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
plot(fit1)
class(fit1)="gcdnet"
source("plot.gcdnet.R")
plot(fit1)
source("utilities.R")
class(fit1)="gcdnet"
plot(fit1)
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
# output
outlist <- getoutput(fit1, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit1$npass, jerr = fit1$jerr))
class(outlist) <- c("hsvmpath")
outlist
library(Matrix)
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
# output
outlist <- getoutput(fit1, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit1$npass, jerr = fit1$jerr))
class(outlist) <- c("hsvmpath")
outlist
class(fit1)="gcdnet"
plot(fit1)
setwd("D:\\GitHub\\powerfamily")
dyn.load("hsvmlassoNET.dll")
x <- matrix(rnorm(100*10),100,10)
y <- sample(c(-1,1),100,replace=TRUE)
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlam = nlambda = 100
method = c("hhsvm","logit", "sqsvm", "ls")
lambda.factor = ifelse(nobs < nvars, 0.01, 1e-04)
lambda = NULL; lambda2 = 0.5
pf = rep(1, nvars); pf2 = rep(1, nvars)
# exclude,
dfmax = nvars + 1; pmax = min(dfmax * 1.2, nvars); standardize = TRUE
eps = 1e-08; maxit = 1e+06; q = 2 ; delta = 2
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
source("plot.gcdnet.R")
source("utilities.R")
library(Matrix)
#dyn.load("auxiliary.dll")
dyn.load("hsvmlassoNET.dll")
dyn.load("powerfamilyNET.dll")
is.loaded("powerfamilyNET")
is.loaded("hsvmlassoNET")
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
# output
outlist <- getoutput(fit1, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit1$npass, jerr = fit1$jerr))
class(outlist) <- c("hsvmpath")
outlist
class(fit1)="gcdnet"
plot(fit1)
outlist
plot.gcdnet(fit1)
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlam = nlambda = 100
method = c("hhsvm","logit", "sqsvm", "ls")
lambda.factor = ifelse(nobs < nvars, 0.01, 1e-04)
lambda = NULL; lambda2 = 0.5
pf = rep(1, nvars); pf2 = rep(1, nvars)
# exclude,
dfmax = nvars + 1; pmax = min(dfmax * 1.2, nvars); standardize = TRUE
eps = 1e-08; maxit = 1e+06; q = 2 ; delta = 2
y <- as.factor(y)
y <- c(-1, 1)[as.numeric(y)]
if (!all(y %in% c(-1, 1)))
stop("y should be a factor with two levels")
if (delta < 0)
stop("delta must be non-negative")
delta <- as.double(delta)
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
source("plot.gcdnet.R")
source("utilities.R")
library(Matrix)
#dyn.load("auxiliary.dll")
dyn.load("hsvmlassoNET.dll")
dyn.load("powerfamilyNET.dll")
is.loaded("powerfamilyNET")
is.loaded("hsvmlassoNET")
fit1 <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1))
alam = double(nlam), npass = integer(1), jerr = integer(1))
# output
outlist <- getoutput(fit1, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit1$npass, jerr = fit1$jerr))
class(outlist) <- c("hsvmpath")
outlist
class(fit1)="gcdnet"
plot.gcdnet(fit1)
class(fit1)
class(fit1)= c("gcdnet", class(fit1))
plot.gcdnet(fit1)
x=beta
x=fit1$beta
beta <- x$beta
x$beta
x=fit1
beta <- x$beta
beta
lambda <- x$lambda
df <- x$df
xvar <- match.arg(xvar)
xvar
xvar="lambda"
xvar
which <- nonzero(beta)
nonzero
which <- nonzero(beta)
nrow(beta)
dim(beta)
length(beta)
beta
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlambda = 100
lambda.factor = ifelse(nobs < nvars, 0.01,1e-04)
lambda = NULL
lambda2 = 0
pf = rep(1, nvars)
pf2 = rep(1, nvars)
#exclude,
dfmax = nvars + 1
pmax = min(dfmax * 1.2, nvars)
standardize = TRUE
eps = 1e-08
maxit = 1e+06
delta = 2
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
dyn.load("hsvmlassoNET.dll")
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlambda = 100
lambda.factor = ifelse(nobs < nvars, 0.01,1e-04)
lambda = NULL
lambda2 = 0
pf = rep(1, nvars)
pf2 = rep(1, nvars)
#exclude,
dfmax = nvars + 1
pmax = min(dfmax * 1.2, nvars)
standardize = TRUE
eps = 1e-08
maxit = 1e+06
delta = 2
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
#parameter setup
if (length(pf) != nvars)
stop("The size of L1 penalty factor must be same as the number of input variables")
if (length(pf2) != nvars)
stop("The size of L2 penalty factor must be same as the number of input variables")
if (lambda2 < 0)
stop("lambda2 must be non-negative")
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
if (!missing(exclude)) {
jd <- match(exclude, seq(nvars), 0)
if (!all(jd > 0))
stop("Some excluded variables out of range")
jd <- as.integer(c(length(jd), jd))
} else jd <- as.integer(0)
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlambda = 100
lambda.factor = ifelse(nobs < nvars, 0.01,1e-04)
lambda = NULL
lambda2 = 0
pf = rep(1, nvars)
pf2 = rep(1, nvars)
#exclude,
dfmax = nvars + 1
pmax = min(dfmax * 1.2, nvars)
standardize = TRUE
eps = 1e-08
maxit = 1e+06
delta = 2
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
#parameter setup
if (length(pf) != nvars)
stop("The size of L1 penalty factor must be same as the number of input variables")
if (length(pf2) != nvars)
stop("The size of L2 penalty factor must be same as the number of input variables")
if (lambda2 < 0)
stop("lambda2 must be non-negative")
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
#################################################################################
#lambda setup
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
fit
#################################################################################
#data setup
y <- as.factor(y)
y <- c(-1, 1)[as.numeric(y)]
if (!all(y %in% c(-1, 1)))
stop("y should be a factor with two levels")
if (delta < 0)
stop("delta must be non-negative")
delta <- as.double(delta)
#################################################################################
# call Fortran core
fit <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1),
PACKAGE = "gcdnet")
#################################################################################
# output
outlist <- getoutput(fit, maxit, pmax, nvars, vnames)
outlist <- c(outlist, list(npasses = fit$npass, jerr = fit$jerr))
class(outlist) <- c("hsvmpath")
outlist
if (is.null(lambda))
fit$lambda <- lamfix(fit$lambda)
fit$call <- this.call
#################################################################################
class(fit) <- c("gcdnet", class(fit))
fit
fit <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1),
PACKAGE = "gcdnet")
y <- drop(y)
x <- as.matrix(x)
np <- dim(x)
nobs <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x)
nlambda = 100
lambda.factor = ifelse(nobs < nvars, 0.01,1e-04)
lambda = NULL
lambda2 = 0
pf = rep(1, nvars)
pf2 = rep(1, nvars)
#exclude,
dfmax = nvars + 1
pmax = min(dfmax * 1.2, nvars)
standardize = TRUE
eps = 1e-08
maxit = 1e+06
delta = 2
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
#parameter setup
if (length(pf) != nvars)
stop("The size of L1 penalty factor must be same as the number of input variables")
if (length(pf2) != nvars)
stop("The size of L2 penalty factor must be same as the number of input variables")
if (lambda2 < 0)
stop("lambda2 must be non-negative")
maxit <- as.integer(maxit)
lam2 <- as.double(lambda2)
pf <- as.double(pf)
pf2 <- as.double(pf2)
isd <- as.integer(standardize)
eps <- as.double(eps)
dfmax <- as.integer(dfmax)
pmax <- as.integer(pmax)
jd <- as.integer(0)
#################################################################################
#lambda setup
nlam <- as.integer(nlambda)
if (is.null(lambda)) {
if (lambda.factor >= 1)
stop("lambda.factor should be less than 1")
flmin <- as.double(lambda.factor)
ulam <- double(1)
} else {
#flmin=1 if user define lambda
flmin <- as.double(1)
if (any(lambda < 0))
stop("lambdas should be non-negative")
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
#################################################################################
#data setup
y <- as.factor(y)
y <- c(-1, 1)[as.numeric(y)]
if (!all(y %in% c(-1, 1)))
stop("y should be a factor with two levels")
if (delta < 0)
stop("delta must be non-negative")
delta <- as.double(delta)
#################################################################################
# call Fortran core
fit <- .Fortran("hsvmlassoNET", delta, lam2, nobs, nvars,
as.double(x), as.double(y), jd, pf, pf2, dfmax, pmax, nlam,
flmin, ulam, eps, isd, maxit, nalam = integer(1), b0 = double(nlam),
beta = double(pmax * nlam), ibeta = integer(pmax), nbeta = integer(nlam),
alam = double(nlam), npass = integer(1), jerr = integer(1),
PACKAGE = "gcdnet")
